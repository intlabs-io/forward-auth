package server

import (
	"context"
	"fmt"
	"io/ioutil"
	"net/http"
	"path/filepath"
	"sync"

	"bitbucket.org/_metalogic_/config"
	fauth "bitbucket.org/_metalogic_/forward-auth"
	_ "bitbucket.org/_metalogic_/forward-auth/docs" // docs is generated by Swag CLI, you have to import it.
	httpSwagger "bitbucket.org/_metalogic_/httptreemux-swagger"
	"bitbucket.org/_metalogic_/log"
	"github.com/BurntSushi/toml"
	"github.com/dimfeld/httptreemux/v5"
)

const rootGUID = "ROOT"

// AuthzServer ...
type AuthzServer struct {
	server *http.Server
	store  fauth.Store
	auth   *fauth.Auth
	info   map[string]string
}

// Config holds the configuration read from a config file
// - JWTHeader is the name of the header in requests that carries a user JSON Web Token
// - UserHeader is the name of the header containing the user identifier extracted from the JWT
//   and returned by forward-auth; Traefik attaches UserHeader to the request for downstream consumption
// - RootToken is the name of the tenant API token that is treated as ROOT
// - Tokens is a list of token names to be looked up in the environment or in secrets
// - Tenants is a list of tenant names to be looked up in the environment or in secrets
type Config struct {
	JWTHeader  string   `toml:"jwtHeader"`
	UserHeader string   `toml:"userHeader"`
	RootToken  string   `toml:"rootToken"`
	Tokens     []string `toml:"Tokens"`
	Tenants    []string `toml:"Tenants"`
}

func Start(addr, runMode, tenantParam, userHeader, traceHeader string, store fauth.Store, wg *sync.WaitGroup) (svr *AuthzServer) {

	conf, err := ReadConfig("/usr/local/etc/forward-auth")
	if err != nil {
		log.Fatal(err)
	}

	acs, err := store.Load()
	if err != nil {
		log.Fatal(err)
	}

	var tokens = make(map[string]string)
	// tokens maps bearer tokens to token names that are used to express conditions in access rules; the map contains
	//   mappings of tokens to tenant IDs and application names:
	//   |  TOKEN  |  Tenant ID  (the tenant ID to which the token is assigned)
	//   |  TOKEN  |  Application Token Name  | (the application token name that is authorized to use the token)
	//
	// add token mappings from token value to token name
	for _, token := range conf.Tokens {
		if token == conf.RootToken { // associate tenant token with token name "ROOT_TOKEN"
			tokens[config.MustGetConfig(token)] = "ROOT_TOKEN"
		} else {
			tokens[config.MustGetConfig(token)] = token
		}
	}

	// TODO: institution bearer tokens are hard-coded for now
	// when we get real multi-tenant access to the APIs this map should be populated from institutions-api
	// and should subscribe to changes to institutions-config
	// application and institution bearer token names (token values are stored in Docker secrets named by $ENV_$TOKEN_NAME);
	//
	// add token mappings from tenant token value to tenantID
	for _, t := range conf.Tenants {
		tenantID := t + "_ID"     // eg ACME_ID
		token := t + "_API_TOKEN" // eg ACME_API_TOKEN
		tokens[config.MustGetConfig(token)] = config.MustGetConfig(tenantID)
	}

	// block list of usernames, hostnames, IP addresses
	blocks := make(map[string]bool)

	// RSA Public Key
	publicKey, err := config.GetRawSecret("IDENTITY_PROVIDER_PUBLIC_KEY")
	if err != nil {
		log.Fatal(err)
	}

	// Symmetric secret key
	secretKey := []byte(config.MustGetConfig("JWT_SECRET_KEY"))
	// TODO jwtRefreshKey := []byte(config.MustGetConfig("JWT_REFRESH_SECRET_KEY"))

	auth, err := fauth.NewAuth(acs, conf.JWTHeader, publicKey, secretKey, tokens, blocks)
	if err != nil {
		log.Fatal(err)
	}

	// auth := fauth.NewAuth(addr)
	svr = &AuthzServer{
		server: &http.Server{
			Addr:    addr,
			Handler: router(auth, store, userHeader, traceHeader)},
		auth:  auth,
		store: store,
		info:  make(map[string]string),
	}

	log.Debugf("configured authorization environment %+v", svr)

	// listen for changes on the store
	go func() {
		defer wg.Done() // let caller know we are done cleaning up
		store.Listen(auth.UpdateFunc())
	}()

	// start the HTTP server
	go func() {
		defer wg.Done() // let main know we are done cleaning up

		// always returns error. ErrServerClosed on graceful close
		if err := svr.server.ListenAndServe(); err != http.ErrServerClosed {
			// unexpected error. port in use?
			log.Fatalf("ListenAndServe(): %v", err)
		}
	}()

	// returning reference so caller can call Shutdown()
	return svr
}

// Stats returns server statistics
// TODO keep running stats of authorization request handling
func (svc *AuthzServer) Stats() string {
	js := fmt.Sprintf("{\"Requests\": %d, \"Allowed\" : %d, \"Denied\": %d}", 100, 50, 50)
	return js
}

func (svc *AuthzServer) Shutdown(ctx context.Context) {
	svc.store.Close()
	if err := svc.server.Shutdown(ctx); err != nil {
		log.Fatal(err)
	}
	log.Warning("shutdown HTTP server")
}

// create the router for Service
func router(auth *fauth.Auth, store fauth.Store, userHeader, traceHeader string) *httptreemux.TreeMux {
	// initialize HTTP router
	treemux := httptreemux.New()
	api := treemux.NewGroup("/")

	// Common endpoints
	api.GET("/health", Health(store))
	api.GET("/info", APIInfo(store))
	api.GET("/stats", Stats(store))

	// Admin endpoints
	api.GET("/admin/loglevel", LogLevel())
	api.PUT("/admin/loglevel/:verbosity", SetLogLevel())
	api.GET("/admin/run", RunMode())
	api.PUT("/admin/run/:mode", SetRunMode())
	api.GET("/admin/tree", Tree(auth))
	api.GET("/openapi/*", httpSwagger.Handler(
		httpSwagger.URL("doc.json"), // The url pointing to API definition
		httpSwagger.DeepLinking(true),
		httpSwagger.DocExpansion("none"),
		httpSwagger.DomID("#swagger-ui")))

	// Auth endpoints
	api.GET("/auth", Auth(auth, userHeader, traceHeader))
	api.POST("/auth/update", Update(auth, store)) // called by deployment-api broadcast to trigger update from store
	api.GET("/block", Blocked(auth))
	api.POST("/block/:userGUID", Block(auth))
	api.DELETE("/block/:userGUID", Unblock(auth))

	database, err := store.Database()
	if err != nil {
		log.Fatal(err)
	}
	// ACS endpoints
	api.GET("/hostgroups", HostGroups(database))
	api.POST("/hostgroups", CreateHostGroup(userHeader, database))
	api.GET("/hostgroups/:groupGUID", HostGroup(database))
	api.PUT("/hostgroups/:groupGUID", UpdateHostGroup(userHeader, database))
	api.DELETE("/hostgroups/:groupGUID", DeleteHostGroup(database))

	api.GET("/hostgroups/:groupGUID/hosts", Hosts(database))
	api.POST("/hostgroups/:groupGUID/hosts", CreateHost(userHeader, database))
	api.GET("/hostgroups/:groupGUID/hosts/:hostGUID", Host(database))
	api.PUT("/hostgroups/:groupGUID/hosts/:hostGUID", UpdateHost(userHeader, database))
	api.DELETE("/hostgroups/:groupGUID/hosts/:hostGUID", DeleteHost(database))

	api.GET("/hostgroups/:groupGUID/checks", Checks(database))
	api.POST("/hostgroups/:groupGUID/checks", CreateCheck(userHeader, database))
	api.GET("/hostgroups/:groupGUID/checks/:checkGUID", Check(database))
	api.PUT("/hostgroups/:groupGUID/checks/:checkGUID", UpdateCheck(userHeader, database))
	api.DELETE("/hostgroups/:groupGUID/checks/:checkGUID", DeleteCheck(database))

	api.GET("/hostgroups/:groupGUID/checks/:checkGUID/paths", Paths(database))
	api.POST("/hostgroups/:groupGUID/checks/:checkGUID/paths", CreatePath(userHeader, database))
	api.GET("/hostgroups/:groupGUID/checks/:checkGUID/paths/:pathGUID", Path(database))
	api.PUT("/hostgroups/:groupGUID/checks/:checkGUID/paths/:pathGUID", UpdatePath(userHeader, database))
	api.DELETE("/hostgroups/:groupGUID/checks/:checkGUID/paths/:pathGUID", DeletePath(database))

	return treemux
}

// ReadConfig reads configuration from file
func ReadConfig(configPath string) (conf Config, err error) {
	file := filepath.Join(configPath, "file.toml")
	data, err := ioutil.ReadFile(file)
	if err != nil {
		return conf, err
	}
	err = toml.Unmarshal(data, &conf)
	if err != nil {
		return conf, err
	}
	jwtHeader := config.IfGetenv("JWT_HEADER_NAME", "X-Jwt-Header")
	if conf.JWTHeader == "" {
		conf.JWTHeader = jwtHeader
	}
	log.Debugf("loaded config from '%s': %+v", file, conf)
	return conf, nil
}
