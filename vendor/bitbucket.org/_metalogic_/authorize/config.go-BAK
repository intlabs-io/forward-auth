package authz

import (
	"fmt"
	"log/slog"
	"sync"

	"bitbucket.org/_metalogic_/authenticate/jwt"
	"bitbucket.org/_metalogic_/log"
	"bitbucket.org/_metalogic_/pat"
)

// Config type holds data for authorization
//   - TODO - do we need this???  owner - is the owner of the current forward-auth deployment
//   - disabled - if true disables authorization (replaces runMode="noAuth")
//   - jwtHeader - is the name of the header containing the user's JWT
//   - keyFunc - is a function passed to JWT parse function to return the key for decrypting the JWT token
//   - sessions - is a map of session IDs to session objects containing user JWT tokens
//   - publicKeys - maps key names to their rsa.PublicKey value
//   - tokens - maps bearer token values passed in an authorization request to token names referenced in
//     access control functions; eg: bearer(ROOT_KEY) returns true if the bearer token
//     in the request maps to the token name ROOT_KEY
//   - blocks - is a map of subjects (usernames, groupnames, IP addresses) to be denied
//     access; subject names must be unique for all subjects
//
// an instance of Config is passed to rule handlers to drive authorization evaluation
type Config struct {
	owner        Owner
	disabled     bool
	handler      Handler
	rootOverride bool
	sessionConf  *Sessions
	jauth        *jwt.Config
	tokens       map[string]string
	blocks       map[string]bool
	overrides    map[string]string
	mutex        sync.RWMutex // prevent concurrent update
	groupMuxers  map[string]*pat.GroupMux
}

// New returns a new RSA Auth
func New(acs *AccessSystem, handler Handler, rootOverride bool, sessionConf *Sessions, jauth *jwt.Config) (conf *Config, err error) {

	conf = &Config{
		owner:        acs.Owner,
		rootOverride: rootOverride,
		jauth:        jauth,
		sessionConf:  sessionConf,
		groupMuxers:  make(map[string]*pat.GroupMux),
		tokens:       acs.Tokens,
		blocks:       acs.Blocks,
		handler:      handler,
	}

	err = conf.setAccess(conf.handler, acs.Authorization, false)
	if err != nil {
		return conf, err
	}

	return conf, nil
}

func (conf *Config) Disabled() bool {
	return conf.disabled
}

func (conf *Config) SetDisabled(v bool) bool {
	conf.disabled = v
	return conf.disabled
}

// CheckBearerAuth checks for token in list of tokens returning true if found
func (conf *Config) CheckBearerAuth(token string, tokens ...string) bool {
	for _, t := range tokens {
		if t == conf.tokens[token] {
			slog.Debug("allowing by bearer token '%s'", redact(token))
			return true
		}
	}
	slog.Debug("rejecting token '%s' by bearer auth for accepted tokens: %v", redact(token), tokens)
	return false
}

func (conf *Config) setAccess(handler Handler, checks *Authorization, refresh bool) error {
	if checks == nil {
		log.Warning("empty group checks for auth")
		return nil
	}
	conf.overrides = checks.Overrides

	// create Pat Group Muxers from Checks
	for _, group := range checks.GroupChecks {
		// default to deny
		groupMux := pat.NewDenyMux()
		if group.Default == "allow" {
			groupMux = pat.NewAllowMux()
		}
		// each group shares the groupMux
		for _, group := range group.Groups {
			if v, ok := conf.overrides[group]; ok {
				log.Warningf("%s override on group %s disables defined group checks", v, group)
			}
			if _, ok := conf.getMux(group); !refresh && ok {
				log.Errorf("ignoring duplicate group checks for %s", group)
				continue
			}
			conf.setMux(group, groupMux)
		}
		// add uri prefixes to groupMux
		for _, check := range group.Checks {
			// deny if action + uri is not found
			uriPrefix := groupMux.AddPrefix(check.Base, pat.NotFoundHandler)
			for _, uri := range check.Paths {
				if rule, ok := uri.Rules["GET"]; ok {
					uriPrefix.Get(uri.Path, handler.Handle(rule, conf))
				}
				if rule, ok := uri.Rules["POST"]; ok {
					uriPrefix.Post(uri.Path, handler.Handle(rule, conf))
				}
				if rule, ok := uri.Rules["PUT"]; ok {
					uriPrefix.Put(uri.Path, handler.Handle(rule, conf))
				}
				if rule, ok := uri.Rules["PATCH"]; ok {
					uriPrefix.Patch(uri.Path, handler.Handle(rule, conf))
				}
				if rule, ok := uri.Rules["DELETE"]; ok {
					uriPrefix.Del(uri.Path, handler.Handle(rule, conf))
				}
				if rule, ok := uri.Rules["HEAD"]; ok {
					uriPrefix.Head(uri.Path, handler.Handle(rule, conf))
				}
				if rule, ok := uri.Rules["OPTIONS"]; ok {
					uriPrefix.Options(uri.Path, handler.Handle(rule, conf))
				}
			}
		}
	}
	return nil
}

func (conf *Config) setTokens(tokens map[string]string) {
	conf.tokens = tokens
}

func (conf *Config) setMux(group string, mux *pat.GroupMux) {
	conf.mutex.Lock()
	defer conf.mutex.Unlock()
	conf.groupMuxers[group] = mux
}

func (conf *Config) getMux(group string) (mux *pat.GroupMux, ok bool) {
	conf.mutex.RLock()
	defer conf.mutex.RUnlock()
	mux, ok = conf.groupMuxers[group]
	return mux, ok
}

func (conf *Config) Blocked() (blocked []string) {
	for k := range conf.blocks {
		if conf.blocks[k] {
			blocked = append(blocked, k)
		}
	}
	return blocked
}

func (conf *Config) Block(user string) {
	conf.blocks[user] = true
}

func (conf *Config) Unblock(user string) {
	conf.blocks[user] = false
}

func (conf *Config) Override(group string) string {
	return conf.overrides[group]
}

func (conf *Config) RootOverride() bool {
	return conf.rootOverride
}

func (conf *Config) RunMode() string {
	if conf.disabled {
		return "disabled"
	}
	return "enabled"
}

// Muxer returns the pattern mux for group
func (conf *Config) Muxer(group string) (mux *pat.GroupMux, err error) {
	var ok bool
	if mux, ok = conf.getMux(group); ok {
		return mux, nil
	}
	return mux, fmt.Errorf("group checks not defined for %s", group)
}

// GroupChecks returns JSON formatted group checks
// func (auth *Auth) GroupChecks() (groupChecksJSON string, err error) {
// 	data, err := json.Marshal(conf.GroupChecks)
// 	if err != nil {
// 		return groupChecksJSON, err
// 	}
// 	return string(data), nil
// }

// UpdateFunc returns a function to update access system
// func (auth *Auth) UpdateFunc() (f func(*AccessSystem) error) {
// 	return func(acs *AccessSystem) error {
// 		conf.setTokens(acs.Tokens)
// 		conf.setRSAPublicKeys(acs.PublicKeys)
// 		return conf.setAccess(acs.Authorization, true)
// 	}
// }
